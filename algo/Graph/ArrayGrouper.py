"""
Label an array as in scipy.ndimage.label, but with extra functionality
	* Create a containment tree, which sorts labels in order of closeness
	  to outside the array.
	* Use different contiguity structures for different values in the array.

The standard labeling procedure, which uses the same structure for each value,
is implemented in ArrayGrouper. To use different structures for different
values, use ArrayGrouperMultiPattern.
"""
import numpy as np
from numpy import inf
from numba import njit, typed, types
from numba.typed import List, Dict
from numba.types import UniTuple, ListType, DictType
from numba import int_, bool_
from numba.experimental import jitclass

from common.collections import Queue

from .__ArrayGrouper_functions__ import __functions__

class _ArrayGrouper:
	"""Label an array of integers and generate a containment tree for it.
	
	To label an array means to identify all the contiguous groups of that array
	and assign to each group a unique label, in this case returned as another
	array of identical shape to the input array, but filled with integer labels.
	This functionality is identical to that provided by scipy.ndimage.label.
	
	Where this class adds novel functinoality is in the containment tree.
	The containment tree indicates the order in which one would encounter
	groups in the array proceeding inwards from outside the array.
	A containment tree satisfies the following properties:
		* It contains each unique generated label only once.
		* The depth at which a label is contained in this tree is the minimal
		  separation degree from the outside of the array. E.g. if a group
		  borders the array extern, its minimal separation degree is 0,
		  because to get to the outside from that group does not reqiure
		  traversing through any other groups. If instead you are at a group
		  and you have to go through at least one other group in order to get
		  to the outside, then group 1 has a minimal separation of 1, and is
		  found at depth 1 in the tree.
		* Parents and children are related in a depth-wise sense: a child
		  has a minimal separation degree exactly one greater than its parent
		  (compatible with the fact that it has depth one greater than its parent).
		  Parents may have multiple children, children may have multiple parents.
		  Parents may also have no children, but every node at depth>0 has at
		  least one parent.
		* It is acyclic (as trees are), by the above properties.
	
	In order to generate a containment tree, one must have a mapping
	that tells, for each label in the output, which other labels border it,
	and which of these labels border the array's outside. To generate this
	information from a label array generated by scipy would repeat a lot of
	calculation already performed. This class computes this information
	dynamically so that it is immediately available upon completion of the
	labeling process.
	
	At the moment the containment tree may be generated in two ways:
		* implicitly: a flat dictionary where each key in the dict (a label)
		  points to a conntainer of other keys (labels) in the dict, such that
		  the pointers do not violate the aforementioned properties of the
		  containment tree. Because the structure of this tree is fully known
		  at compile time, this functionality is implemented as a compiled
		  method on this class; see the 'generate_implicit_tree' method.
		* explicitly: the tree is returned as nested dicts, where dict keys
		  are integers representing label nodes and dict values are dicts
		  representing children of the respective labels. Because of numba
		  type-inference issues, this is not compiled, and therefore is not
		  a method of this class; the module-level function `generate_tree`
		  can be called on an instance to achieve this. Note, since each label
		  exists only once in the tree, if two different labels point to a
		  common child label, they will point to the same dictionary objects
		  in memory.
	
	If you do not want the containment tree, this class also allows for
	retrieving the intermediary data structures used to compute it:
	namely, an adjacency list (dict of int:array pairs) telling which
	groups connect to which others, and another mapping telling which
	groups border the array's outside.
	"""
	def __init__(self, array, pattern = np.array([[0,1,0],[1,0,1],[0,1,0]]),
				 symmetric_pattern = True):
		"""Initialize an instance with a 2d array of integers.
		
		Other data structures are created upon intialization.
		
		Other parameters:
			:: pattern (numba.int_[:, ::1]) ::
				2d array of values to be interpeted in a boolean sense
				telling, relative to the center coordinate of the array,
				whether a neighbor should be evaluated for contiguity.
				Currently only a 3-by-3 array is supported.
			:: symmetric_pattern (bool) ::
				Tells whether the pattern is expected to be symmetric or not
				about its center (this ensures transitivity of contiguity).
				If True (default), raise ValueError if an asymmetric pattern
				is provided. If False, do nothing.
		"""
		
		self.generic_init(array)
		
		if symmetric_pattern: self._evaluate_symmetric_pattern(pattern)
		
		row,col = pattern.shape
		assert row == 3 and col == 3, 'pass a 3 x 3 array for `pattern`'
		self.neighbor_searcher = np.array([ # relative coordinates to look for neighbors
			(i,j) for i in range(row) for j in range(col)
			if pattern[i][j]
		]) - np.array([1,1]) # assumes pattern.shape==(3,3)
	
	def _get_potential_neighbors(self, value=-1):
		"""For ArrayGrouper, this returns the self.neighbor_searcher."""
		# why pass a keyword that is not used?
		# for consistency of the interface on which this class is based,
		# which becomes important when defining _ArrayGrouperMultiPattern
		return self.neighbor_searcher

# at the moment, numba does not allow for inheritance in compiled classes
# the workaround is to assign the common functions to each class before
# compilation from outside, and define class-specific routines internally
for name, f in __functions__.items():
	setattr(_ArrayGrouper, name, f)

# to compile the class, specify type signatures for instance attributes
ArrayGrouper = jitclass(dict(
	rows = int_, # integer
	cols = int_,
	counter=int_,
	has_been_run=bool_, # boolean
	
	array=int_[:, ::1], # C-ordered 2-d integer array
	groups=int_[:, ::1],
	neighbor_searcher = int_[:, ::1],
	
	borders_outside = DictType(int_, bool_), # dict mapping <int: boolean>
	group_referenced_values = DictType(int_, int_),
	
	bordered_by = DictType(int_, int_[:, ::1]), # dict values can be arrays
	bordering_groups = DictType(int_, int_[::1])
))(_ArrayGrouper)

from sys import maxsize
class _ArrayGrouperMultiPattern:
	def __init__(self, array, patterns, symmetric_pattern = True,
				 default_pattern = np.array([[0,1,0],[1,0,1],[0,1,0]])):
		"""Initialize an instance with a 2d array of integers.
		
		Other data structures are created upon intialization.
		
		Other parameters:
			:: pattern (DictType(int_, int[:, ::1])) ::
				Mapping of integer label values to integer arrays that represent
				neighbor search patterns, as in the `pattern` argument to the
				ArrayGrouper class constructor.
			:: default_pattern (numba.int_[:, ::1]) ::
				2d array of values to be interpeted in a boolean sense
				telling, relative to the center coordinate of the array,
				whether a neighbor should be evaluated for contiguity.
				Currently only a 3-by-3 array is supported. This pattern
				applies when a value is found not covered by the `patterns`
				parameter.
			:: symmetric_pattern (bool) ::
				Tells whether the pattern is expected to be symmetric or not
				about its center (this ensures transitivity of contiguity).
				If True (default), raise ValueError if an asymmetric pattern
				is provided. If False, do nothing.
		"""
		
		self.generic_init(array)
		_neighbor_searchers = {}
		for v,p in patterns.items():
			if symmetric_pattern:
				self._evaluate_symmetric_pattern(p)
			
			row, col = p.shape
			assert (row, col) == (3, 3), 'pass a 3 x 3 array for each pattern'
			_neighbor_searchers[v] = np.array([ # relative coordinates to look for neighbors
				(i,j) for i in range(row) for j in range(col)
				if p[i][j]
			]) - np.array([1,1]) # assumes p.shape==(3,3)
		
		self.neighbor_searchers = _neighbor_searchers
		
		if symmetric_pattern:
			self._evaluate_symmetric_pattern(default_pattern)
		assert default_pattern.shape==(3,3), 'pass a 3 x 3 array for default_pattern'
		self.default_neighbor_searcher = np.array([
			(i,j) for i in range(row) for j in range(col)
			if default_pattern[i][j]
		]) - np.array([1,1]) # assumes default_pattern.shape==(3,3)
	
	def _get_potential_neighbors(self, value, absent = np.array([[maxsize],[maxsize]])):
		"""Get the neighbor searcher for the value passed. If the value
		is not defined in self.neighbor_searchers, return
		self.default_neighbor_searcher."""
		ns = self.neighbor_searchers.get(value, absent)
		if ns[0,0] == maxsize:
			return self.default_neighbor_searcher
		return ns
	
for name, f in __functions__.items():
	setattr(_ArrayGrouperMultiPattern, name, f)

ArrayGrouperMultiPattern = jitclass(dict(
	rows = int_,
	cols = int_,
	counter=int_,
	has_been_run=bool_
	
	array=int_[:, ::1],
	groups=int_[:, ::1],
	
	borders_outside = DictType(int_, bool_),
	group_referenced_values = DictType(int_, int_),
	
	default_neighbor_searcher = int_[:, ::1],
	bordered_by = DictType(int_, int_[:, ::1]),
	bordering_groups = DictType(int_, int_[::1]),
	neighbor_searchers = DictType(int_, int_[:, ::1]),
))(_ArrayGrouperMultiPattern)









def generate_tree(self, depthwise = True, breadthwise = True):
	"""Generate an explicit containment tree representing the structure
	of a labeled array contained by an array grouper instance. See the
	documentation for that class for details of what this function returns.
	ArrayGrouper and ArrayGrouperMultiPattern follow the same interface,
	so this method works for instances of either class."""
	if not self.has_been_run:
		raise RuntimeError('cannot generate tree before instance has been processed')
	
	# placeholder that makes computational flow simpler
	# -1 points to values bordering the outside
	self.bordering_groups[-1] = np.array([group_id for group_id, b in self.borders_outside.items() if b])
	if not depthwise:
		# return a plain graph as an adjacency list
		return {group_id:set(neighbors) for group_id, neighbors in self.bordering_groups.items()}
	
	# use a queue to process one level at a time
	q = Queue()
	children_dict = {}
	q.push((-1, 0, children_dict)) # group_id, depth, children dictionary
	visited = {-1:(0, children_dict)} # map <group_id: depth in tree, children dictionary for group_id>
	
	default = (None, None)
	while q:
		group_id, depth, children_dict = q.pop()
		children_ids = (g for g in self.bordering_groups[group_id])
		for c in children_ids:
			# check to see if this label has already been visited
			cdepth, cdict = visited.get(c, default)
			# if so...
			if cdepth is not None:
				# only add as a child of current label if the depth is right
				if cdepth > depth:
					children_dict[c] = cdict
				# continue either way since the label was already visited
				continue
			
			# if the label was not already visited, make a new dict for it,
			# add it to the queue, and record it as visited
			d = {}
			children_dict[c] = d
			q.push((c, depth+1, d))
			visited[c] = (depth+1, d)
	
	# remove the nonce group we added earlier
	self.bordering_groups.pop(-1)
	# -1 points to the top level of the tree
	return visited[-1][1]

if __name__ == '__main__':		
	def test_array(array, display=False, verbose=False, cls = ArrayGrouper, **kw):
		g = cls(array, **kw)
		
		if display:
			print('array:')
			print(array)
		
		g.label()
		
		implicit_tree = g.generate_implicit_tree()
		
		tree = generate_tree(g)
		if display:
			print('\ng.groups:',g.groups,sep='\n')
			print('\ng.group_referenced_values:',g.group_referenced_values)
			if verbose: print('\ng.bordered_by:',g.bordered_by,sep='\n')
			print('\ng.borders_outside:',g.borders_outside,sep='\n')
			print('\ng.bordering_groups:',g.bordering_groups,sep='\n')
			
			print('\ntree:', tree)
			print('\ngraph (adj. list):', generate_tree(g, False))
		
		return g, tree, implicit_tree
	
	if True: # ArrayGrouper tests
		array = np.array(
				[[1, 1, 3, 3],
				 [1, 0, 0, 3],
				 [3, 2, 2, 1],
				 [3, 3, 1, 1]])
		
		g, tree, implicit_tree = test_array(array)
		assert tree == {0:{2:{}}, 1:{2:{}}, 3:{4:{}}, 5:{4:{}}}
		assert {g:set(c) for g,c in implicit_tree.items()} == \
			{-1:{0,1,3,5}, 0:{2,}, 1:{2,}, 3:{4,}, 5:{4,}, 2:set(), 4:set()}
		
		# print((',\n'.join(f'[{", "*8}]' for _ in range(8))))
		array = np.array(
				[[0, 0, 0, 0, 0, 1, 2, 3, 1],
				 [0, 0, 0, 0, 1, 1, 2, 3, 1],
				 [0, 0, 0, 1, 1, 2, 2, 3, 1],
				 [0, 0, 4, 4, 2, 2, 3, 3, 1],
				 [0, 0, 5, 0, 0, 3, 3, 3, 1],
				 [6, 6, 6, 6, 0, 7, 7, 7, 1],
				 [7, 7, 7, 8, 0, 8, 8, 8, 1],
				 [9, 9, 9, 8, 8, 8, 1, 1, 1]])
		
		g, tree, implicit_tree = test_array(array)
		assert tree == {
			# level 0
			0:{5:{}, 6:{}}, 1:{5:{}}, 2:{5:{}, 7:{}}, 3:{7:{}, 9:{}}, 4:{9:{}},
			# level 1
			8:{6:{}, 7:{}}, 10:{}, 11:{7:{}, 9:{}}, 12:{}
		}
		assert {g:set(c) for g,c in implicit_tree.items()} == {
			-1:{0,1,2,3,4,8,10,11,12}, # depth = -1
			0:{5,6}, 1:{5,}, 2:{5,7}, 3:{7,9}, 4:{9,}, # depth = 0
				8:{6,7}, 10:set(), 11:{7,9}, 12:set(),
			5:set(), 6:set(), 7:set(), 9:set() # depth = 1
		}
	
	if True: # ArrayGrouperMultiPattern tests
		four_way_pattern = np.array([[0,1,0],[1,0,1],[0,1,0]])
		eight_way_pattern = np.array([[1,1,1],[1,0,1],[1,1,1]])
		
		array = np.array(
				[[1, 1, 0, 0],
				 [1, 1, 0, 0],
				 [0, 0, 1, 1],
				 [0, 0, 1, 1]])
		
		patterns = Dict(dcttype=DictType(int_, int_[:,::1]))
		patterns[0], patterns[1] = four_way_pattern, eight_way_pattern
		
# 		print('patterns:',patterns)
		g, tree, implicit_tree = test_array(
			array, cls = ArrayGrouperMultiPattern,
			patterns = patterns
		)
		assert np.array_equal(
			g.groups,
			np.array([[0,0,1,1],[0,0,1,1],[2,2,0,0],[2,2,0,0]])
		)
		
		assert tree == {0:{}, 1:{}, 2:{}}
		assert {g:set(c) for g,c in implicit_tree.items()} == \
			{-1:{0,1,2}, 0:set(), 1:set(), 2:set()}
		
		patterns[0] = eight_way_pattern
		array = np.array(
				[[0, 2, 0, 0, 2],
				 [1, 0, 2, 2, 0],
				 [0, 1, 0, 2, 0],
				 [0, 1, 1, 0, 2],
				 [1, 0, 0, 1, 0]])
		
		for i in range(3):
			if i==0:
				kw, patterns[2] = {} , four_way_pattern
			elif i==1:
				kw['default_pattern'] = four_way_pattern
				del patterns[2]
			elif i==2:
				kw['default_pattern'] = eight_way_pattern
			g, tree, implicit_tree = test_array(
				array, cls = ArrayGrouperMultiPattern,
				patterns = patterns, **kw
			)
			if i<2:
				assert np.array_equal(g.groups,
						[[0, 1, 0, 0, 2],
						 [3, 0, 4, 4, 0],
						 [0, 3, 0, 4, 0],
						 [0, 3, 3, 0, 5],
						 [3, 0, 0, 3, 0]]
				)
				assert tree == {0:{4:{}}, 1:{}, 2:{}, 3:{4:{}}, 5:{}}, str(tree)
				"""this is an interesting case: 3 reports 4 as being a child, but
				4 would not report 3 as being a parent, because 4's definition of contiguity
				is different than 3's, and from 4 one cannot jump to three, though from 3 one
				may jump to 4. What to do about such cases--anything? """
				assert {g:set(c) for g,c in implicit_tree.items()} == \
					{-1:{0,1,2,3,5}, 0:{4,}, 1:set(()), 2:set(()), 3:{4,}, 4:set(()), 5:set(())}
			elif i==2:
				assert np.array_equal(g.groups,
						[[0, 1, 0, 0, 1],
						 [2, 0, 1, 1, 0],
						 [0, 2, 0, 1, 0],
						 [0, 2, 2, 0, 1],
						 [2, 0, 0, 2, 0]]
				)
				assert tree == {0:{}, 1:{}, 2:{}}, str(tree)
				assert {g:set(c) for g,c in implicit_tree.items()} == \
					{-1:{0,1,2}, 0:set(()), 1:set(()), 2:set(())}
	