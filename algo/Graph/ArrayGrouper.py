"""
Label an array as in scipy.ndimage.label, but with extra functionality
	* Create a containment tree, which sorts labels in order of closeness
	  to outside the array.
	* Use different contiguity structures for different values, whether
	  by explicitly defining them or by providing a callable
	  (not yet implemented)
"""
import numpy as np
from numpy import inf
from numba import njit, typed, types
from numba.typed import List, Dict
from numba.types import UniTuple, ListType, DictType
from numba import int_, bool_
from numba.experimental import jitclass

from common.collections import Queue

class _ArrayGrouper:
	"""Label an array of integers and generate a containment tree for it.
	
	To label an array means to identify all the contiguous groups of that array
	and assign to each group a unique label, in this case returned as another
	array of identical shape to the input array, but filled with integer labels.
	This functionality is identical to that provided by scipy.ndimage.label.
	
	Where this class adds novel functinoality is in the containment tree.
	A containment tree satisfies the following properties:
		* It contains each unique generated label only once.
		* The depth at which a label is contained in this tree is the minimal
		  separation degree from the outside of the array. E.g. if a group
		  borders the array extern, its minimal separation degree is 0,
		  because to get to the outside from that group does not reqiure
		  traversing through any other groups. If instead you are at a group
		  and you have to go through at least one other group in order to get
		  to the outside, then group 1 has a minimal separation of 1, and is
		  found at depth 1 in the tree.
		* Parents and children are related in a depth-wise sense: a child
		  has a minimal separation degree exactly one greater than its parent
		  (compatible with the fact that it has depth one greater than its parent).
		  Parents may have multiple children, children may have multiple parents.
		  Parents may also have no children, but every node at depth>0 has at
		  least one parent.
		* It is acyclic, by the above properties.
	
	In order to generate a containment tree, one must have a mapping
	that tells, for each label in the output, which other labels border it,
	and which of these labels border the array's outside. To generate this
	information from a label array generated by scipy would repeat a lot of
	calculation already performed. This class computes this information
	dynamically so that it is immediately available upon completion of the
	labeling process.
	
	At the moment the containment tree may be generated in two ways:
		* implicitly: a flat dictionary where each key in the dict (a label)
		  points to a conntainer of other keys (labels) in the dict, such that
		  the pointers do not violate the aforementioned properties of the
		  containment tree. Because the structure of this tree is fully known
		  at compile time, this functionality is implemented as a compiled
		  method on this class; see the 'generate_implicit_tree' method.
		* explicitly: the tree is returned as nested dicts, where dict keys
		  are integers representing label nodes and dict values are dicts
		  representing children of the respective labels. Because of numba
		  type-inference issues, this is not compiled, and therefore is not
		  a method of this class; the module-level function `generate_tree`
		  can be called on an instance to achieve this. Note, since each label
		  exists only once in the tree, if two different labels point to a
		  common child label, they will point to the same dictionary objects
		  in memory.
	
	If you do not want the containment tree, this class also allows for
	retrieving the intermediary data structures used to compute it:
	namely, an adjacency list (dict of int:array pairs) telling which
	groups connect to which others, and another mapping telling which
	groups border the array's outside.
	
	*Note* : this class is numba-compiled for efficiency. At the moment,
	due to the difficulty of creating arbitrarily-nested hash maps, the function
	that generates the containment tree is not compiled and is contained outside
	of this class. There are ways to change this, including the creation of a
	compiled Tree class, or the implicit construction of a containment tree,
	i.e. , maintaining the above properties. The implicit tree is a
	simpler option; however, at the moment I have not been able to get numba to
	compile my implementation of this option, so it is not yet available.
	"""
	def _evaluate_symmetric_pattern(self, pattern):
		"""Evaluate whether a given pattern is centrosymmetric. Used internally."""
		r,c = pattern.shape
		
		if not (r%2) or (c%2):
			raise ValueError(
				'pattern is required to have odd dimensions: has dimensions' 
				+ str(r) + str(c)
			)
		
		# center coordinate of the array
		center_r, center_c = r//2, c//2
		
		# this receives row & column indices if an asymmetry is found
		error = List.empty_list(int_)
		
		# for all rows up to middle rows, scan all columns
		for i in range(center_r):
			for j in range(c):
				if pattern[i,j] != pattern[2*center_r - i, 2*center_c - j]:
					error.append(i)
					error.append(j)
					break
			else:
				# if we didn't break, go to the next iteration of the outer loop
				continue
			# if we did break, then break outer loop as well
			break
		# don't keep scanning if we already found a mismatch
		if not error:
			# for middle row, scan only up to before center column
			for j in range(center_c):
				if pattern[center_r,j] != pattern[center_r, 2*center_c - j]:
					error.append(center_r)
					error.append(j)
					break
		if error:
			i,j = error
			error_message_pieces = List([
				'error: pattern not symmetric: p[', str(i),', ',str(j),']:',
				str(pattern[i,j]),' != ','p[', str(2*center_r - i),
				', ',str(2*center_c),']:',
				str(pattern[2*center_r - i, 2*center_c - j])
			])
			print(''.join(error_message_pieces))
			raise ValueError('pattern not symmetric')
	
	def __init__(self, array, *, pattern = np.array([[0,1,0],[1,0,1],[0,1,0]]),
				 symmetric_pattern = True):
		"""Initialize an instance with a 2d array of integers.
		
		Other data structures are created upon intialization.
		
		Other parameters:
			:: pattern (numba.int_[:, ::1]) ::
				2d array of values to be interpeted in a boolean sense
				telling, relative to the center coordinate of the array,
				whether a neighbor should be evaluated for contiguity.
				Currently only a 3-by-3 array is supported.
			:: symmetric_pattern (bool) ::
				Tells whether the pattern is expected to be symmetric or not
				about its center (this ensures transitivity of contiguity).
				If True (default), raise ValueError if an asymmetric pattern
				is provided. If False, do nothing.
		"""
		self.array = array
		self.groups = np.full_like(array, -1) # to hold the label values
		row,col = pattern.shape
		assert row == 3 and col == 3, 'pass a 3 x 3 array for `pattern`'
		self.rows, self.cols = array.shape
		self.neighbor_searcher = np.array([ # relative coordinates to look for neighbors
			(i,j) for i in range(row) for j in range(col)
			if pattern[i][j]
		]) - np.array([1,1]) # NOTE: this assumes pattern.shape==(3,3)
		
		self.counter = 0
		self.has_been_run = False
		
		# mapping <group id: 2-column array where each row is a cell coordinate>
		# note: we would rather have Set(UniTuple(int_, 2)) for the value type,
		# but at the moment numba (v0.51.2) rejects with an error:
		# "set(UniTuple(int64 x 2)) as value is forbidden"
		bordered_by = {}
		bordered_by[-1] = np.empty((2,2),int_) # gets numba to infer signature accurately
		self.bordered_by = bordered_by
		self.bordered_by.pop(-1)
		
		# mapping <group id: the value in self.array that the group refers to>
		self.group_referenced_values = Dict.empty(int_,int_)
		
		# mapping <group id: bool(does the group border the outside of the array?)>
		self.borders_outside = Dict.empty(int_,bool_)
		
		# mapping <group id: unique group_id integers of bordering groups>
		# can't specify empty Dict here, leads to compilation errors--
		# presumably a numba issue having to do with the value type being an array
		self.bordering_groups = {-1:np.empty(0,int_)}
		self.bordering_groups.pop(-1)
	
	def _borders_outside(self, i, j):
		"""For a cell at coordinate (i,j), tell whether this cell
		borders the outside of the array."""
		return (i==0) or (i==self.rows-1) or (j==0) or (j==self.cols-1)
	
	def _get_potential_neighbors(self):
		return self.neighbor_searcher
	
	def _neighbors_of_cell(self, ij):
		"""
		Get neighbors of cell, both matching and nonmatching,
		and return together in a 2-column array, where the last
		row in the array tells the number of nonmatching and matching
		neighbors.
		
		Parameters:
		:: ij (UniTuple(-int_, 2)) :: coordinate of the cell
		"""
		i,j = ij
		value = self.array[i,j]
		rows,cols = self.rows, self.cols
		
		neighbors = []
		# for each neighbor, keep a boolean value to tell if its value matches
		match = List.empty_list(bool_)
		
		for r,c in self._get_potential_neighbors():
			# neighbor_searcher gives relative coordinates; add to get cell coordiantes
			neighbor_r, neighbor_c = i+r, j+c
			
			# ensure coordinate points inside the array
			if (0<=neighbor_r<self.rows) and (0<=neighbor_c<self.cols):
				# matching or not, the neighbor is added
				neighbors.append((neighbor_r, neighbor_c))
				if self.array[neighbor_r, neighbor_c]==value:
					match.append(True)
				else:
					match.append(False)
		
		return neighbors, match
	
	def _find_group_and_neighbors(self, i, j):
		"""Determine and associate the group for a cell at coordinate (i,j).
		This operation mutates the instance's internal data structures."""
		
		# -1 means cell has not yet been evaluated; anything else means it has
		if self.groups[i,j] != -1:
			return
		
		value = self.array[i,j]
		
		# stack is efficiently implemented as a list, so go this route
		stack = List([(i,j)])
		
		# set of matching cells; to start, include the input cell by default
		matching = set([(i,j)])
		nonmatching = set([(-1,-1)]) # allows numba to auto-detect signature
		nonmatching.remove((-1,-1))
		
		# DFS traversal to find contiguous, matching cells
		# at the end of this loop, matching contains all members of this group,
		# and nonmatching contains all the unique neighbor cells of this group
		while len(stack)!=0:
			current = stack.pop()
			neighbors, match = self._neighbors_of_cell(current)
			for n,m in zip(neighbors,match):
				if m:
					# here we have to check explicitly, because the stack
					# only receives the cell if it is not already present
					if n not in matching:
						matching.add(n)
						stack.append(n)
				else:
					# here we don't have to check explicitly--the .add method
					# handles both cases when cell is or is not present
					nonmatching.add(n)
		
		# self.counter increments for each new group
		group_id = self.counter
		
		# set the label (group id) for all cells
		for i,j in matching:
			self.groups[i,j] = group_id
		
		# convert to arrays to match signature
		self.bordered_by[group_id] = np.array(list(nonmatching), dtype=int_)
		# 'value' is the value in the original array, 'group_id' is the label
		self.group_referenced_values[group_id] = value
		
		# find whether or not this group borders the array's outside
		for i,j in matching:
			if self._borders_outside(i,j):
				# all we need is one outer cell to yield True
				self.borders_outside[group_id] = True
				break
		else:
			# only get here if we didn't break out of the above loop
			self.borders_outside[group_id] = False
		
		self.counter += 1
	
	def label(self):
		"""Given the instance's input array, find its labeled array:
		find all contiguous groups in the array (as done by scipy.ndimage.label),
		but also generate data structures required to make a containment
		tree from the labeled array (not provided by scipy's function).
		"""
		# associate every cell with a group, caching results along the way
		# to maintain linear time complexity
		for i in range(self.rows):
			for j in range(self.cols):
				self._find_group_and_neighbors(i,j)
		
		# now we get the unique labels that border each group
		for group_id, neighbors_array in self.bordered_by.items():
			s = set([-1]) # numba type signature determination
			s.pop()
			# get unique labels that border current group
			for i,j in neighbors_array:
				s.add(self.groups[i,j])
			
			self.bordering_groups[group_id] = np.array(list(s))
		
		# mark the iteration as complete
		self.has_been_run = True
	
	def generate_implicit_tree(self):
		"""Generate an implicit tree for the labeled array. See the class
		documentation for details of what is returned."""
		if not self.has_been_run:
			raise RuntimeError('cannot generate tree before instance has been processed')
		
		tree = {} # mapping <label: array of labels with one-greater depth>
		outer = np.array( # the outer groups comprise the top level of the tree
			[group_id for group_id, b in self.borders_outside.items() if b],
			dtype=int_
		)
		tree[-1] = outer
		
		# keep track of what not to add to the queue
		visited = Dict.empty(int_, int_)
		
		# q functions as a queue;
		# the fact that it is a queue, not a stack, is important
		q=set(outer)
		
		# top-level depth = 0 by definition
		depth = 0
		
		while q:
			for label in q:
				visited[label] = depth
			
			# `new` holds labels at the next depth that are discovered below
			new = set([-1]) # numba type signature detection
			new.remove(-1)
			
			# temp = List.empty_list(int_) # this doesn't work
			#     NotImplementedError: ListType[int64] cannot be represented as a Numpy dtype
			
			# `temp` stores new labels discovered at the next depth
			# ultimately, these will be added to the queue
			temp = [-1] # workaround
			temp.pop()
			
			# for each label in q, get its children labels and assign them
			# to 'new' so that they can go into q for the next while iteration
			for label in q:
				for neighboring_label in self.bordering_groups[label]:
					value = (neighboring_label in visited)
# 					if n not in visited: # numba bug? This doesn't work
					
					# we add the value to the queue in two cases:
					
					# case 1: the value has not been seen before
					if value==False:
						temp.append(neighboring_label)
					# case 2: the value has been seen and has a greater depth.
					# In this case, it will still only be evaluated once as
					# a member of q, because each level (depth) of the tree
					# is processed one at a time.
					elif visited[neighboring_label] > depth:
						temp.append(neighboring_label)
				
				# for this label, assign its children as the value in the tree
				tree[label] = np.array(temp, dtype=int_)
				# temp contains children of the current node, which are all at
				# the next depth level, so add them to 'new'
				new.update(temp)
				# clear the list so it can be reused,
				# rather than create a new list at each iteration
				temp.clear()
			# 'new' contains the labels at the next depth level, so assign to q
			q = new
			depth+=1
			
		return tree

def generate_tree(self, depthwise = True, breadthwise = True):
	"""Generate an explicit containment tree representing the structure
	of a labeled array contained by an ArrayGrouper instance. See the
	documentation for that class for details of what this function returns."""
	if not self.has_been_run:
		raise RuntimeError('cannot generate tree before instance has been processed')
	
	# placeholder that makes computational flow simpler
	# -1 points to values bordering the outside
	self.bordering_groups[-1] = np.array([group_id for group_id, b in self.borders_outside.items() if b])
	if not depthwise:
		# return a plain graph as an adjacency list
		return {group_id:set(neighbors) for group_id, neighbors in self.bordering_groups.items()}
	
	# use a queue to process one level at a time
	q = Queue()
	children_dict = {}
	q.push((-1, 0, children_dict)) # group_id, depth, children dictionary
	visited = {-1:(0, children_dict)} # map <group_id: depth in tree, children dictionary for group_id>
	
	default = (None, None)
	while q:
		group_id, depth, children_dict = q.pop()
		children_ids = (g for g in self.bordering_groups[group_id])
		for c in children_ids:
			# check to see if this label has already been visited
			cdepth, cdict = visited.get(c, default)
			# if so...
			if cdepth is not None:
				# only add as a child of current label if the depth is right
				if cdepth > depth:
					children_dict[c] = cdict
				# continue either way since the label was already visited
				continue
			
			# if the label was not already visited, make a new dict for it,
			#add it to the queue, and record it as visited
			d = {}
			children_dict[c] = d
			q.push((c, depth+1, d))
			visited[c] = (depth+1, d)
	
	# remove the nonce group we added earlier
	self.bordering_groups.pop(-1)
	# -1 points to the top level of the tree
	return visited[-1][1]

ArrayGrouper = jitclass(dict(
	rows = int_,
	cols = int_,
	neighbor_searcher = int_[:, ::1],
	bordered_by = DictType(int_, int_[:, ::1]),
	group_referenced_values = DictType(int_, int_),
	borders_outside = DictType(int_, bool_),
	bordering_groups = DictType(int_, int_[::1]),
	array=int_[:, ::1],
	groups=int_[:, ::1],
	counter=int_,
	has_been_run=bool_
))(_ArrayGrouper)

_ArrayGrouperMultiPattern = type

if __name__ == '__main__':		
	def test_array(array, display=False, verbose=False):
		g = ArrayGrouper(array)
		
		if display:
			print('array:')
			print(array)
		
		g.label()
		
		implicit_tree = g.generate_implicit_tree()
		
		tree = generate_tree(g)
		if display:
			print('\ng.groups:',g.groups,sep='\n')
			print('\ng.group_referenced_values:',g.group_referenced_values)
			if verbose: print('\ng.bordered_by:',g.bordered_by,sep='\n')
			print('\ng.borders_outside:',g.borders_outside,sep='\n')
			print('\ng.bordering_groups:',g.bordering_groups,sep='\n')
			
			print('\ntree:', tree)
			print('\ngraph (adj. list):', generate_tree(g, False))
		
		return g, tree, implicit_tree
	
	array = np.array(
			[[1, 1, 3, 3],
			 [1, 0, 0, 3],
			 [3, 2, 2, 1],
			 [3, 3, 1, 1]])
	
	g, tree, implicit_tree = test_array(array)
	assert tree == {0:{2:{}}, 1:{2:{}}, 3:{4:{}}, 5:{4:{}}}
	assert {g:set(c) for g,c in implicit_tree.items()} == {-1:{0,1,3,5}, 0:{2,}, 1:{2,}, 3:{4,}, 5:{4,}, 2:set(), 4:set()}
	
	# print((',\n'.join(f'[{", "*8}]' for _ in range(8))))
	array = np.array(
			[[0, 0, 0, 0, 0, 1, 2, 3, 1],
			 [0, 0, 0, 0, 1, 1, 2, 3, 1],
			 [0, 0, 0, 1, 1, 2, 2, 3, 1],
			 [0, 0, 4, 4, 2, 2, 3, 3, 1],
			 [0, 0, 5, 0, 0, 3, 3, 3, 1],
			 [6, 6, 6, 6, 0, 7, 7, 7, 1],
			 [7, 7, 7, 8, 0, 8, 8, 8, 1],
			 [9, 9, 9, 8, 8, 8, 1, 1, 1]])
	
	g, tree, implicit_tree = test_array(array)
	assert tree == {
		0:{5:{}, 6:{}}, 1:{5:{}}, 2:{5:{}, 7:{}}, 3:{7:{}, 9:{}}, 4:{9:{}},
		8:{6:{}, 7:{}}, 10:{}, 11:{7:{}, 9:{}}, 12:{}
	}
	assert {g:set(c) for g,c in implicit_tree.items()} == {
		-1:{0,1,2,3,4,8,10,11,12},
		0:{5,6}, 1:{5,}, 2:{5,7}, 3:{7,9}, 4:{9,}, 8:{6,7}, 10:set(), 11:{7,9}, 12:set(),
		5:set(), 6:set(), 7:set(), 9:set()
	}