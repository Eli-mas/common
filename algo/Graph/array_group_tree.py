import numpy as np
from numpy import inf
from numba import njit, typed, types
from numba.typed import List, Dict
from numba.types import UniTuple, ListType, DictType
from numba import int_, bool_
from numba.experimental import jitclass

@jitclass(dict(
	rows = int_,
	cols = int_,
	neighbor_searcher = int_[:, ::1],
	bordered_by = DictType(int_, int_[:, ::1]),
	group_referenced_values = DictType(int_, int_),
	borders_outside = DictType(int_, bool_),
	bordering_groups = DictType(int_, int_[::1]),
	array=int_[:, ::1],
	groups=int_[:, ::1],
	counter=int_,
	has_been_run=bool_
))
class ArrayGrouper:
	"""Label an array of integers and generate a containment tree for it.
	
	To label an array means to identify all the contiguous groups of that array
	and assign to each group a unique label, in this case returned as another
	array of identical shape to the input array, but filled with integer labels.
	This functionality is identical to that provided by scipy.ndimage.label.
	
	Where this class adds novel functinoality is in the containment tree.
	A containment tree satisfies the following properties:
		* It contains each unique generated label only once.
		* The depth at which a label is contained in this tree is the minimal
		  separation degree from the outside of the array. E.g. if a group
		  borders the array extern, its minimal separation degree is 0,
		  because to get to the outside from that group does not reqiure
		  traversing through any other groups. If instead you are at a group
		  and you have to go through at least one other group in order to get
		  to the outside, then group 1 has a minimal separation of 1, and is
		  found at depth 1 in the tree.
		* Parents and children are related in a depth-wise sense: a child
		  has a minimal separation degree exactly one greater than its parent
		  (compatible with the fact that it has depth one greater than its parent).
		  Parents may have multiple children, children may have multiple parents.
		  Parents may also have no children, but every node at depth>0 has at
		  least one parent.
		* It is acyclic, by the above properties.
	
	In order to generate a containment tree, one must have a mapping
	that tells, for each label in the output, which other labels border it,
	and which of these labels border the array's outside. To generate this
	information from a label array generated by scipy would repeat a lot of
	calculation already performed. This class computes this information
	dynamically so that it is immediately available upon completion of the
	labeling process.
	
	At the moment the containment tree is returned as an arbitarily nested
	dict: a dict whose keys are labels and whose values are dicts, in turn
	whose keys are labels and whose values are dicts, and so on.
	
	If you do not want the containment tree, this class also allows for
	retrieving the intermediary data structures used to compute it:
	namely, an adjacency list (dict of int:array pairs) telling which
	groups connect to which others, and another mapping telling which
	groups border the array's outside.
	
	*Note* : this class is numba-compiled for efficiency. At the moment,
	due to the difficulty of creating arbitrarily-nested hash maps, the function
	that generates the containment tree is not compiled and is contained outside
	of this class. There are ways to change this, including the creation of a
	compiled Tree class, or the implicit construction of a containment tree,
	i.e. a flat dictionary where each key in the dict points to an array of other
	keys in the dict, maintaining the above properties. The implicit tree is a
	simpler option; however, at the moment I have not been able to get numba to
	compile my implementation of this option, so it is not yet available.
	"""
	def _evaluate_symmetric_pattern(self, pattern):
		"""Evaluate whether a given pattern is centrosymmetric. Used internally."""
		r,c = pattern.shape
		
		if not (r%2) or (c%2):
			raise ValueError(
				'pattern is required to have odd dimensions: has dimensions' 
				+ str(r) + str(c)
			)
		
		center_r, center_c = r//2, c//2
		
		error = List.empty_list(int_)
		
		# for all rows up to middle rows, scan all columns
		for i in range(center_r):
			for j in range(c):
				if pattern[i,j] != pattern[2*center_r - i, 2*center_c - j]:
					error.append(i)
					error.append(j)
					break
			else:
				# if we didn't break, go to the next iteration of the outer loop
				continue
			# if we did break, then break outer loop as well
			break
		# don't keep scanning if we already found a mismatch
		if not error:
			# for middle row, scan only up to before center column
			for j in range(center_c):
				if pattern[center_r,j] != pattern[center_r, 2*center_c - j]:
					error.append(center_r)
					error.append(j)
					break
		if error:
			i,j = error
			error_message_pieces = List([
				'error: pattern not symmetric: p[', str(i),', ',str(j),']:',
				str(pattern[i,j]),' != ','p[', str(2*center_r - i),
				', ',str(2*center_c),']:',
				str(pattern[2*center_r - i, 2*center_c - j])
			])
			print(''.join(error_message_pieces))
			raise ValueError('pattern not symmetric')
	
	def __init__(self, array, *, pattern = np.array([[0,1,0],[1,0,1],[0,1,0]]),
				 symmetric_pattern = True):
		"""Initialize an instance with a 2d array of integers.
		
		Other parameters:
			:: pattern (numba.int_[:, ::1]) ::
				2d array of values to be interpeted in a boolean sense
				telling, relative to the center coordinate of the array,
				whether a neighbor should be evaluated for contiguity.
				Currently only a 3-by-3 array is supported.
			:: symmetric_pattern (bool) ::
				Tells whether the pattern is expected to be symmetric or not
				about its center (this ensures transitivity of contiguity).
				If True (default), raise ValueError if an asymmetric pattern
				is provided. If False, do nothing.
		"""
		self.array = array
		self.groups = np.full_like(array, -1)
		row,col = pattern.shape
		assert row == 3 and col == 3, 'pass a 3 x 3 array for `pattern`'
		self.rows, self.cols = array.shape
		self.neighbor_searcher = np.array([
			(i,j) for i in range(row) for j in range(col)
			if pattern[i][j]
		]) - np.array([1,1]) # NOTE: this assumes pattern.shape==(3,3)
		
		self.counter = 0
		self.has_been_run = False
		
		bordered_by = {} # group id: 2-column array where each row is a cell coordiante
		bordered_by[-1] = np.empty((2,2),int_) # gets numba to infer signature accurately
		self.bordered_by = bordered_by
		self.bordered_by.pop(-1)
		
		self.group_referenced_values = Dict.empty(int_,int_) # group id: the value in self.array that the group refers to
		self.borders_outside = Dict.empty(int_,bool_) # group id: bool(does the group border the outside of the array?)
		
		bordering_groups = {} # group id: unique group_id integers of bordering groups
		bordering_groups[-1] = np.empty(0,int_) # gets numba to infer signature accurately
		self.bordering_groups = bordering_groups
		bordering_groups.pop(-1)
	
	def _borders_outside(self, i, j):
		"""For a cell at coordinate (i,j), tell whether this cell
		borders the outside of the array."""
		return (i==0) or (i==self.rows-1) or (j==0) or (j==self.cols-1)
	
# 	def _find_groups_2d(array):
	
	def _neighbors_of_cell(self, ij):
		"""
		Get neighbors of cell, both matching and nonmatching,
		and return together in a 2-column array, where the last
		row in the array tells the number of nonmatching and matching
		neighbors.
		"""
		i,j = ij
		value = self.array[i,j]
		rows,cols = self.rows, self.cols
		match=List.empty_list(bool_)
		neighbors = []
		for r,c in self.neighbor_searcher:
			neighbor_r, neighbor_c = i+r, j+c
# 			print('neighbor_r, neighbor_c:',neighbor_r, neighbor_c)
			if (0<=neighbor_r<self.rows) and (0<=neighbor_c<self.cols):
				neighbors.append((neighbor_r, neighbor_c))
				if self.array[neighbor_r, neighbor_c]==value:
# 					print('\tmatch')
					match.append(True)
				else:
# 					print('\tno match')
					match.append(False)
# 			else:
# 				print('\tnot evaluated')
		
		return neighbors, match
	
	def _find_group_and_neighbors(self, i, j):
		"""Determine and associate the group for a cell at coordinate (i,j).
		This operation mutates the instance's internal data structures."""
		if self.groups[i,j] != -1:
			return
		
		value = self.array[i,j]
		
		stack = List([(i,j)])
		
		matching = set([(i,j)])
		nonmatching = set([(-1,-1)])
		nonmatching.remove((-1,-1))
		
		while len(stack)!=0:
			current = stack.pop()
			neighbors, match = self._neighbors_of_cell(current)
			for n,m in zip(neighbors,match):
# 				print('value:',value,'neighbor:',n,'is a match:',m)
				if m:
					if n not in matching:
# 						print('value:',value,'adding neighbor to matching:',n,'value matches:',value==self.array[n[0],n[1]])
						matching.add(n)
						stack.append(n)
				else:
					if n not in nonmatching:
# 						print('value:',value,'adding neighbor to nonmatching:',n)
						nonmatching.add(n)
		
		group_id = self.counter
		
# 		print('value:',value,'matching:',matching)
		for i,j in matching:
			self.groups[i,j] = group_id
		
		self.bordered_by[group_id] = np.array(list(nonmatching))
		self.group_referenced_values[group_id] = value
		
		for i,j in matching:
			if self._borders_outside(i,j):
				self.borders_outside[group_id] = True
				break
		else:
			self.borders_outside[group_id] = False
		
		self.counter += 1
	
	# def _crawl_wall(array, row, col, direction_of_outside):
	
	def label(self):
		"""Given the instance's input array, find its labeled array:
		find all contiguous groups in the array (as done by scipy.ndimage.label),
		but also generate data structures required to make a containment
		tree from the labeled array (not provided by scipy's function).
		"""
		for i in range(self.rows):
			for j in range(self.cols):
				self._find_group_and_neighbors(i,j)
		
		# at this point we have filled in all cells in self.groups
		# with the group of that cell (an integer identifier)
		# we also have a list of neighbors that border each group
		# so now get the unique groups that border each group
		
		for group_id, neighbors_array in self.bordered_by.items():
			s = set([-1])
			s.pop()
			for i,j in neighbors_array:
				s.add(self.groups[i,j])
			
			self.bordering_groups[group_id] = np.array(list(s))
		
		self.has_been_run = True
	
	def generate_implicit_tree(self):
		# tree = Dict.empty(int_, int_[::1])
		tree = {}
		outer = np.array([group_id for group_id, b in self.borders_outside.items() if b], dtype=int_)
		tree[-1] = outer
		visited = Dict.empty(int_, int_)
# 		visited = {}
# 		visited[-1] = -1
		q=set(outer)
		depth = 0
		while q:
# 			print('q:',q)
# 			print('\tvisited:',visited,0 in visited)
			for g in q:
# 				print('\tsetting depth for', g)
				visited[g] = depth
			new = set([-1])
			new.remove(-1)
			
			# temp = List.empty_list(int_)
			temp = [-1]
			temp.pop()
			for g in q:
# 				print('\tgetting children for', g)
				for n in self.bordering_groups[g]:
					value = (n in visited)
# 					print('\t\tn:',n,value)
# 					if n not in visited: # numba bug? This doesn't work
					if value==False:
# 						print('\t\t\tvalue is False')
# 						print('\t\t\t'+str(n)+' not in visited')
						temp.append(n)
# 					elif value==True:
# 						print('value is True')
					elif visited[n] > depth:
						temp.append(n)
				tree[g] = np.array(temp, dtype=int_)
				new.update(temp)
				temp.clear()
			q = new
			depth+=1
# 			break
		return tree
	
def generate_tree(self, depthwise = True, breadthwise = True):
	from common.collections import Queue
	if not self.has_been_run:
		return
	
	self.bordering_groups[-1] = np.array([group_id for group_id, b in self.borders_outside.items() if b])
	if not depthwise:
		# return a plain graph as an adjacency list
		return {group_id:set(neighbors) for group_id, neighbors in self.bordering_groups.items()}
	
	s = Queue()
	children_dict = {}
	s.push((-1, 0, children_dict)) # group_id, depth, children dictionary
	visited = {-1:(0, children_dict)} # map <group_id: depth in tree, children dictionary for group_id>
	_inf = [inf]
	while s:
		group_id, depth, children_dict = s.pop()
		children_ids = (g for g in self.bordering_groups[group_id])
# 		print(f'group_id = {group_id}, depth={depth}')
# 		print('\tneighbors:',self.bordering_groups[group_id])
# 		print('\tdepths:',[visited.get(n, _inf)[0] for n in self.bordering_groups[group_id]])
# 		print('\tchildren:')
		for c in children_ids:
			if c in visited:
				if visited[c][0] > depth:
# 					print(f'\t\t{c} ALREADY VISITED')
					children_dict[c] = visited[c][1]
# 				else:
# 					print(f'\t\t{c} NOT A CHILD')
				continue
			
# 			print(f'\t\t{c}')
			d = {}
			children_dict[c] = d
			s.push((c, depth+1, d))
			visited[c] = (depth+1, d)
# 		print('\tchildren_dict:',children_dict)
	
	self.bordering_groups.pop(-1)
	return visited[-1][1]

if __name__ == '__main__':		
	def test_array(array, display=False, verbose=False):
		g = ArrayGrouper(array)
		
		if display:
			print('array:')
			print(array)
		
		g.label()
		
		implicit_tree = g.generate_implicit_tree()
		
		tree = generate_tree(g)
		if display:
			print('\ng.groups:',g.groups,sep='\n')
			print('\ng.group_referenced_values:',g.group_referenced_values)
			if verbose: print('\ng.bordered_by:',g.bordered_by,sep='\n')
			print('\ng.borders_outside:',g.borders_outside,sep='\n')
			print('\ng.bordering_groups:',g.bordering_groups,sep='\n')
			
			print('\ntree:', tree)
			print('\ngraph (adj. list):', generate_tree(g, False))
		
		return g, tree, implicit_tree
	
	array = np.array(
			[[1, 1, 3, 3],
			 [1, 0, 0, 3],
			 [3, 2, 2, 1],
			 [3, 3, 1, 1]])
	
	g, tree, implicit_tree = test_array(array)
	assert tree == {0:{2:{}}, 1:{2:{}}, 3:{4:{}}, 5:{4:{}}}
	assert {g:set(c) for g,c in implicit_tree.items()} == {-1:{0,1,3,5}, 0:{2,}, 1:{2,}, 3:{4,}, 5:{4,}, 2:set(), 4:set()}
	
	# print((',\n'.join(f'[{", "*8}]' for _ in range(8))))
	array = np.array(
			[[0, 0, 0, 0, 0, 1, 2, 3, 1],
			 [0, 0, 0, 0, 1, 1, 2, 3, 1],
			 [0, 0, 0, 1, 1, 2, 2, 3, 1],
			 [0, 0, 4, 4, 2, 2, 3, 3, 1],
			 [0, 0, 5, 0, 0, 3, 3, 3, 1],
			 [6, 6, 6, 6, 0, 7, 7, 7, 1],
			 [7, 7, 7, 8, 0, 8, 8, 8, 1],
			 [9, 9, 9, 8, 8, 8, 1, 1, 1]])
	
	g, tree, implicit_tree = test_array(array)
	assert tree == {
		0:{5:{}, 6:{}}, 1:{5:{}}, 2:{5:{}, 7:{}}, 3:{7:{}, 9:{}}, 4:{9:{}},
		8:{6:{}, 7:{}}, 10:{}, 11:{7:{}, 9:{}}, 12:{}
	}
	assert {g:set(c) for g,c in implicit_tree.items()} == {
		-1:{0,1,2,3,4,8,10,11,12},
		0:{5,6}, 1:{5,}, 2:{5,7}, 3:{7,9}, 4:{9,}, 8:{6,7}, 10:set(), 11:{7,9}, 12:set(),
		5:set(), 6:set(), 7:set(), 9:set()
	}